<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Select Area</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      cursor: crosshair;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #controls {
      position: absolute;
      display: none;
      gap: 10px;
    }
    button {
      padding: 10px;
      font-size: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="selectionCanvas"></canvas>
  <div id="controls">
    <button id="cancelButton">X</button>
    <button id="saveButton">Save</button>
  </div>
  <script>
    const canvas = document.getElementById('selectionCanvas');
    const controls = document.getElementById('controls');
    const { ipcRenderer } = require('electron');
    const ctx = canvas.getContext('2d');
    let isDrawing = false;
    let startX, startY, selectedArea;
    let lastAnchorPoint = null;

    function resizeCanvasToWindow() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function positionControls(anchorX, anchorY) {
      // Keep the controls close to the cursor, but never off-screen.
      // We do "flip + clamp": try bottom-right, flip left/up if overflowing, then clamp.
      const margin = 12;
      const offset = 10;
      const rect = controls.getBoundingClientRect();
      const viewportW = window.innerWidth;
      const viewportH = window.innerHeight;

      const maxLeft = Math.max(margin, viewportW - rect.width - margin);
      const maxTop = Math.max(margin, viewportH - rect.height - margin);

      let left = anchorX + offset;
      let top = anchorY + offset;

      if (left + rect.width + margin > viewportW) {
        left = anchorX - rect.width - offset;
      }
      if (top + rect.height + margin > viewportH) {
        top = anchorY - rect.height - offset;
      }

      left = clamp(left, margin, maxLeft);
      top = clamp(top, margin, maxTop);

      controls.style.left = `${Math.round(left)}px`;
      controls.style.top = `${Math.round(top)}px`;
    }

    resizeCanvasToWindow();

    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true;
      startX = e.clientX;
      startY = e.clientY;
      controls.style.display = 'none';
      lastAnchorPoint = null;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const currentX = e.clientX;
      const currentY = e.clientY;
      const x = Math.min(startX, currentX);
      const y = Math.min(startY, currentY);
      const width = Math.abs(currentX - startX);
      const height = Math.abs(currentY - startY);
      ctx.strokeRect(x, y, width, height);
      selectedArea = { x, y, width, height };
    });

    canvas.addEventListener('mouseup', (e) => {
      isDrawing = false;
      if (selectedArea && selectedArea.width > 0 && selectedArea.height > 0) {
        controls.style.display = 'flex';
        lastAnchorPoint = { x: e.clientX, y: e.clientY };
        // Ensure layout is calculated before measuring controls size.
        requestAnimationFrame(() => {
          if (!lastAnchorPoint) return;
          positionControls(lastAnchorPoint.x, lastAnchorPoint.y);
        });
      }
    });

    document.getElementById('cancelButton').addEventListener('click', () => {
      ipcRenderer.send('cancel-selection');
    });

    document.getElementById('saveButton').addEventListener('click', () => {
      if (selectedArea) {
        ipcRenderer.send('area-selected', selectedArea);
      }
    });

    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        ipcRenderer.send('cancel-selection');
      }
    });

    window.addEventListener('resize', () => {
      resizeCanvasToWindow();
      if (controls.style.display !== 'none' && lastAnchorPoint) {
        requestAnimationFrame(() => positionControls(lastAnchorPoint.x, lastAnchorPoint.y));
      }
    });
  </script>
</body>
</html>